#define INITGUID // Include this #define to use SystemTraceControlGuid in
                 // Evntrace.h.

#include <conio.h>
#include <windows.h>
#include <evntcons.h>
#include <evntrace.h>
#include <in6addr.h>
#include <iostream>
#include <stdio.h>
#include <strsafe.h>
#include <tdh.h>
#include "TDH.hpp"
#include <wbemidl.h>
#include <wmistr.h>

void EventHandler(PEVENT_RECORD evt) {
  TDH tdh{evt};
  tdh.print();
}

LPSTR win_strerror(DWORD errorID) {
  LPSTR error_str;
  size_t error_strlen = FormatMessageA(
      FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM |
          FORMAT_MESSAGE_IGNORE_INSERTS,
      NULL, errorID, MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),
      (LPSTR)&error_str, 0, NULL);
  return error_str;
}

typedef struct {
  TRACEHANDLE *trace_handle_ptr;
  bool canceled;
} TraceProcessThreadContext;

DWORD WINAPI TraceProcessThreadMain(LPVOID trace_process_thread_context_ptr) {
  TraceProcessThreadContext *trace_thread_context =
      (TraceProcessThreadContext *)trace_process_thread_context_ptr;

  for (;;) {
    ProcessTrace(trace_thread_context->trace_handle_ptr, 1, nullptr, nullptr);
    if (trace_thread_context->canceled) {
      break;
    }
  }
  return 0;
}

typedef struct {
  EVENT_TRACE_PROPERTIES properties;
  wchar_t logfileName[128];
  wchar_t loggerName[1024];
} EVENT_TRACE_PROPERTIES_WRAPPER;

using EVENTS_T = ULONG;

void configure_wevt_properties(EVENT_TRACE_PROPERTIES_WRAPPER *evtp_wrapper,
                               EVENTS_T events) {
  evtp_wrapper->properties.Wnode.BufferSize =
      sizeof(EVENT_TRACE_PROPERTIES_WRAPPER);
  evtp_wrapper->properties.Wnode.Flags = WNODE_FLAG_TRACED_GUID;
  evtp_wrapper->properties.Wnode.ClientContext = 1; // QPC clock resolution
  evtp_wrapper->properties.Wnode.Guid = SystemTraceControlGuid;
  evtp_wrapper->properties.EnableFlags = events;
  evtp_wrapper->properties.LogFileMode = EVENT_TRACE_REAL_TIME_MODE;
  evtp_wrapper->properties.MaximumFileSize = 5; // 5 MB
  evtp_wrapper->properties.LoggerNameOffset =
      offsetof(EVENT_TRACE_PROPERTIES_WRAPPER, loggerName);
  evtp_wrapper->properties.LogFileNameOffset =
      0; // Required for real-time logging.
}

void configure_wevt_logfile(PEVENT_TRACE_LOGFILE wevt_logfile) {
  wevt_logfile->LoggerName = const_cast<wchar_t *>(KERNEL_LOGGER_NAME);
  wevt_logfile->ProcessTraceMode =
      PROCESS_TRACE_MODE_EVENT_RECORD | PROCESS_TRACE_MODE_REAL_TIME;
  wevt_logfile->EventRecordCallback = EventHandler;
}

int main() {
  // Because the code uses a _goto_ to consolidate
  // our error-handling code, C++ will not let us
  // goto around declarations and initializers. For
  // this reason, we are required to do all declaration
  // and initialization up front.
  ULONG status{ERROR_SUCCESS};
  TRACEHANDLE session_handle{0};
  EVENT_TRACE_PROPERTIES_WRAPPER evtp_wrapper{0};
  EVENT_TRACE_LOGFILE wevt_logfile{0};
  TRACEHANDLE trace_handle{0};
  HANDLE process_thread_handle{nullptr};
  TraceProcessThreadContext trace_process_thread_context{0};

  // Other events that are traceable are listed online at
  // https://docs.microsoft.com/en-us/windows/win32/api/evntrace/ns-evntrace-event_trace_properties
  EVENTS_T events_to_trace = EVENT_TRACE_FLAG_DISK_FILE_IO;

  configure_wevt_properties(&evtp_wrapper, events_to_trace);
  configure_wevt_logfile(&wevt_logfile);

  status = StartTrace((PTRACEHANDLE)&session_handle, KERNEL_LOGGER_NAME,
                      &evtp_wrapper.properties);

  if (ERROR_SUCCESS != status) {
    if (ERROR_ALREADY_EXISTS == status) {
      wprintf(
          L"An NT Kernel Logger session is already in use. Use xperf -stop.\n");
    } else {
      wprintf(L"Failed to start the trace: Error %lu.\n", status);
    }

    goto cleanup;
  }

  status = trace_handle = OpenTrace(&wevt_logfile);
  if (status == INVALID_PROCESSTRACE_HANDLE) {
    LPSTR error_string = win_strerror(GetLastError());
    std::cout << "Failed to open the trace: " << error_string << "\n";
    LocalFree(error_string);
    goto cleanup;
  }

  trace_process_thread_context.trace_handle_ptr = &trace_handle;
  process_thread_handle =
      CreateThread(nullptr, 0, TraceProcessThreadMain,
                   &trace_process_thread_context, 0, nullptr);

  if (process_thread_handle == nullptr) {
    LPSTR error_string = win_strerror(GetLastError());
    std::cout
        << "Failed to create a thread to read the generated trace events: "
        << error_string << "\n";
    LocalFree(error_string);
    goto cleanup;
  }

  wprintf(L"Press any key to end trace session ");

  /*
   * MSVC++ will not like this because we are disgarding a
   * return value. So, we temporarily disable that warning.
   */
#pragma warning(suppress : 6031)
  _getch();
#pragma warning(default : 6031)

  trace_process_thread_context.canceled = true;

  status = CloseTrace(trace_handle);
  if (status != ERROR_SUCCESS && status != ERROR_CTX_CLOSE_PENDING) {
    LPSTR error_string = win_strerror(GetLastError());
    std::cout << "Failed to close the trace: " << error_string << "\n";
    LocalFree(error_string);
  }

  std::cout << "I am starting to wait for the process thread to finish.\n";
  if (process_thread_handle != nullptr) {
    status = WaitForSingleObject(process_thread_handle, 5000);
    if (status == WAIT_FAILED || status == WAIT_TIMEOUT) {
      LPSTR error_string = win_strerror(GetLastError());
      std::wcout << "Oops: Event-processing thread did not stop in time: "
                 << error_string << "\n"
                 << "Terminating it...\n";
      /*
       * MSVC++ will complain about this because TerminateThread does not
       * allow the thread to clean up resources before it is killed. However,
       * we've given the thread plenty of time at this point.
       */
#pragma warning(suppress : 6258)
      TerminateThread(process_thread_handle, 0);
#pragma warning(default : 6258)

      LocalFree(error_string);
    }
  }
  std::wcout << L"Final cleanup ...\n";

cleanup:

  if (session_handle) {
    status = ControlTrace(session_handle, KERNEL_LOGGER_NAME,
                          &evtp_wrapper.properties, EVENT_TRACE_CONTROL_STOP);
    if (status != ERROR_SUCCESS) {
      wprintf(L"Failed to stop the trace: Error %lu.\n", status);
    }
  }
  return 0;
}
