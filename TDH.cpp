#include "tdh.hpp"
#include <iostream>

#pragma comment(lib, "tdh.lib")

TDH::TDH(PEVENT_RECORD record)
    : m_guid(L""), m_properties(), m_version(), m_opcode(), m_eventid() {
  ProcessEvent(record);
}

void TDH::print() const {
  std::wcout << L"Event GUID: " << m_guid << L"\n";
  std::wcout << L"Event version: " << m_version << L"\n";
  std::wcout << L"Event opcode: " << m_opcode << L"\n";
  std::wcout << L"Event m_eventid: " << m_eventid << L"\n";
  for (auto p : m_properties) {
    std::wcout << p.first << L":" << p.second << "\n";
  }
}

// Begin private helper functions. This code is mostly copy/paste
// from the MSDN.

VOID WINAPI TDH::ProcessEvent(PEVENT_RECORD pEvent) {
  DWORD status = ERROR_SUCCESS;
  PTRACE_EVENT_INFO pInfo = NULL;
  LPWSTR pwsEventGuid = NULL;
  PBYTE pUserData = NULL;
  PBYTE pEndOfUserData = NULL;
  DWORD PointerSize = 0;
  ULONGLONG TimeStamp = 0;
  ULONGLONG Nanoseconds = 0;
  SYSTEMTIME st;
  SYSTEMTIME stLocal;
  FILETIME ft;

  // Skips the event if it is the event trace header. Log files contain this
  // event but real-time sessions do not. The event contains the same
  // information as the EVENT_TRACE_LOGFILE.LogfileHeader member that you can
  // access when you open the trace.

  if (IsEqualGUID(pEvent->EventHeader.ProviderId, EventTraceGuid) &&
      pEvent->EventHeader.EventDescriptor.Opcode == EVENT_TRACE_TYPE_INFO) {
    ; // Skip this event.
  } else {
    // Process the event. The pEvent->UserData member is a pointer to
    // the event specific data, if it exists.

    status = GetEventInformation(pEvent, pInfo);

    if (ERROR_SUCCESS != status) {
      wprintf(L"GetEventInformation failed with %lu\n", status);
      goto cleanup;
    }

    // Determine whether the event is defined by a MOF class, in an
    // instrumentation manifest, or a WPP template; to use TDH to decode
    // the event, it must be defined by one of these three sources.

    if (pInfo->DecodingSource == DecodingSourceWbem) // MOF class
    {
      HRESULT hr = StringFromCLSID(pInfo->EventGuid, &pwsEventGuid);

      if (FAILED(hr)) {
        wprintf(L"StringFromCLSID failed with 0x%x\n", hr);
        status = hr;
        goto cleanup;
      }

      m_guid = std::wstring{pwsEventGuid};

      CoTaskMemFree(pwsEventGuid);
      pwsEventGuid = NULL;

      m_version = pEvent->EventHeader.EventDescriptor.Version;
      m_opcode = pEvent->EventHeader.EventDescriptor.Opcode;

    } else if (pInfo->DecodingSource ==
               DecodingSourceXMLFile) // Instrumentation manifest
    {
      m_eventid = pInfo->EventDescriptor.Id;
    } else // Not handling the WPP case
    {
      std::cout << "Warning: Not handling events formatted in WPP.\n";
      goto cleanup;
    }

    // Print the time stamp for when the event occurred.

    ft.dwHighDateTime = pEvent->EventHeader.TimeStamp.HighPart;
    ft.dwLowDateTime = pEvent->EventHeader.TimeStamp.LowPart;

    FileTimeToSystemTime(&ft, &st);
    SystemTimeToTzSpecificLocalTime(NULL, &st, &stLocal);

    TimeStamp = pEvent->EventHeader.TimeStamp.QuadPart;
    Nanoseconds = (TimeStamp % 10000000) * 100;

    wprintf(L"%02d/%02d/%02d %02d:%02d:%02d.%I64u\n", stLocal.wMonth,
            stLocal.wDay, stLocal.wYear, stLocal.wHour, stLocal.wMinute,
            stLocal.wSecond, Nanoseconds);

    // If the event contains event-specific data use TDH to extract
    // the event data. For this example, to extract the data, the event
    // must be defined by a MOF class or an instrumentation manifest.

    // Need to get the PointerSize for each event to cover the case where you
    // are consuming events from multiple log files that could have been
    // generated on different architectures. Otherwise, you could have accessed
    // the pointer size when you opened the trace above (see
    // pHeader->PointerSize).

    if (EVENT_HEADER_FLAG_32_BIT_HEADER ==
        (pEvent->EventHeader.Flags & EVENT_HEADER_FLAG_32_BIT_HEADER)) {
      PointerSize = 4;
    } else {
      PointerSize = 8;
    }

    pUserData = (PBYTE)pEvent->UserData;
    pEndOfUserData = (PBYTE)pEvent->UserData + pEvent->UserDataLength;

    // Print the event data for all the top-level properties. Metadata for all
    // the top-level properties come before structure member properties in the
    // property information array.

    for (USHORT i = 0; i < pInfo->TopLevelPropertyCount; i++) {
      pUserData = GatherProperties(std::wstring{L""}, pEvent, pInfo,
                                   PointerSize, i, pUserData, pEndOfUserData);
      if (NULL == pUserData) {
        wprintf(L"Printing top level properties failed.\n");
        goto cleanup;
      }
    }
  }

cleanup:

  if (pInfo) {
    free(pInfo);
  }
}

bool TDH::PropertyIsStructure(PEVENT_PROPERTY_INFO event_info) {
  return (event_info->Flags & PropertyStruct) == PropertyStruct;
}

// Print the property.

PBYTE TDH::GatherProperties(const std::wstring &prefix, PEVENT_RECORD pEvent,
                            PTRACE_EVENT_INFO pInfo, DWORD PointerSize,
                            USHORT i, PBYTE pUserData, PBYTE pEndOfUserData) {
  TDHSTATUS status = ERROR_SUCCESS;
  USHORT PropertyLength = 0;
  DWORD FormattedDataSize = 0;
  USHORT UserDataConsumed = 0;
  USHORT UserDataLength = 0;
  LPWSTR pFormattedData = NULL;
  USHORT PropertyArraySize = 0;
  PEVENT_MAP_INFO pMapInfo = NULL;
  std::wstring property_name{L""};

  // Get the length of the property.

  status = GetPropertyLength(pEvent, pInfo, i, &PropertyLength);
  if (ERROR_SUCCESS != status) {
    wprintf(L"GetPropertyLength failed.\n");
    pUserData = NULL;
    goto cleanup;
  }

  // A property may be an array. This is confusing: The properties themselves
  // are stored in an array. Note this difference!

  property_name =
      (PWCHAR)((PBYTE)(pInfo) + pInfo->EventPropertyInfoArray[i].NameOffset);

  status = GetPropertyArraySize(pEvent, pInfo, i, &PropertyArraySize);

  for (USHORT k = 0; k < PropertyArraySize; k++) {
    // If the property is a structure, print the members of the structure.

    if (PropertyIsStructure(&pInfo->EventPropertyInfoArray[i])) {

      DWORD LastMemberIndex =
          pInfo->EventPropertyInfoArray[i].structType.StructStartIndex +
          pInfo->EventPropertyInfoArray[i].structType.NumOfStructMembers;

      for (USHORT j =
               pInfo->EventPropertyInfoArray[i].structType.StructStartIndex;
           j < LastMemberIndex; j++) {
        pUserData = GatherProperties(
            prefix + std::wstring{L"."} + property_name, pEvent, pInfo,
            PointerSize, j, pUserData, pEndOfUserData);
        if (pUserData == NULL) {
          wprintf(L"Printing the members of the structure failed.\n");
          pUserData = NULL;
          goto cleanup;
        }
      }
    } else {
      // Get the name/value mapping if the property specifies a value map.

      status = GetMapInfo(
          pEvent,
          (PWCHAR)((PBYTE)(pInfo) + pInfo->EventPropertyInfoArray[i]
                                        .nonStructType.MapNameOffset),
          pInfo->DecodingSource, pMapInfo);

      if (ERROR_SUCCESS != status) {
        wprintf(L"GetMapInfo failed\n");
        pUserData = NULL;
        goto cleanup;
      }

      // Get the size of the buffer required for the formatted data.

      status = TdhFormatProperty(
          pInfo, pMapInfo, PointerSize,
          pInfo->EventPropertyInfoArray[i].nonStructType.InType,
          pInfo->EventPropertyInfoArray[i].nonStructType.OutType,
          PropertyLength, (USHORT)(pEndOfUserData - pUserData), pUserData,
          &FormattedDataSize, pFormattedData, &UserDataConsumed);

      if (ERROR_INSUFFICIENT_BUFFER == status) {
        if (pFormattedData) {
          free(pFormattedData);
          pFormattedData = NULL;
        }

        pFormattedData = (LPWSTR)malloc(FormattedDataSize);
        if (pFormattedData == NULL) {
          wprintf(L"Failed to allocate memory for formatted data (size=%lu).\n",
                  FormattedDataSize);
          status = ERROR_OUTOFMEMORY;
          pUserData = NULL;
          goto cleanup;
        }

        // Retrieve the formatted data.

        status = TdhFormatProperty(
            pInfo, pMapInfo, PointerSize,
            pInfo->EventPropertyInfoArray[i].nonStructType.InType,
            pInfo->EventPropertyInfoArray[i].nonStructType.OutType,
            PropertyLength, (USHORT)(pEndOfUserData - pUserData), pUserData,
            &FormattedDataSize, pFormattedData, &UserDataConsumed);
      }

      if (ERROR_SUCCESS == status) {
        if (prefix.length() != 0) {

          m_properties.insert(std::make_pair(prefix + property_name,
                                             std::wstring{pFormattedData}));
        } else {
          m_properties.insert(
              std::make_pair(property_name, std::wstring{pFormattedData}));
        }
        pUserData += UserDataConsumed;
      } else {
        wprintf(L"TdhFormatProperty failed with %lu.\n", status);
        pUserData = NULL;
        goto cleanup;
      }
    }
  }

cleanup:

  if (pFormattedData) {
    free(pFormattedData);
    pFormattedData = NULL;
  }

  if (pMapInfo) {
    free(pMapInfo);
    pMapInfo = NULL;
  }

  return pUserData;
}

// Get the length of the property data. For MOF-based events, the size is
// inferred from the data type of the property. For manifest-based events, the
// property can specify the size of the property value using the length
// attribute. The length attribute can specify the size directly or specify
// the name of another property in the event data that contains the size. If
// the property does not include the length attribute, the size is inferred
// from the data type. The length will be zero for variable length,
// null-terminated strings and structures.

DWORD TDH::GetPropertyLength(PEVENT_RECORD pEvent, PTRACE_EVENT_INFO pInfo,
                             USHORT i, PUSHORT PropertyLength) {
  DWORD status = ERROR_SUCCESS;
  PROPERTY_DATA_DESCRIPTOR DataDescriptor;
  DWORD PropertySize = 0;

  // If the property is a binary blob and is defined in a manifest, the
  // property can specify the blob's size or it can point to another property
  // that defines the blob's size. The PropertyParamLength flag tells you
  // where the blob's size is defined.

  if ((pInfo->EventPropertyInfoArray[i].Flags & PropertyParamLength) ==
      PropertyParamLength) {
    DWORD Length = 0; // Expects the length to be defined by a UINT16 or UINT32
    DWORD j = pInfo->EventPropertyInfoArray[i].lengthPropertyIndex;
    ZeroMemory(&DataDescriptor, sizeof(PROPERTY_DATA_DESCRIPTOR));
    DataDescriptor.PropertyName =
        (ULONGLONG)((PBYTE)(pInfo) +
                    pInfo->EventPropertyInfoArray[j].NameOffset);
    DataDescriptor.ArrayIndex = ULONG_MAX;
    status =
        TdhGetPropertySize(pEvent, 0, NULL, 1, &DataDescriptor, &PropertySize);
    status = TdhGetProperty(pEvent, 0, NULL, 1, &DataDescriptor, PropertySize,
                            (PBYTE)&Length);
    *PropertyLength = (USHORT)Length;
  } else {
    if (pInfo->EventPropertyInfoArray[i].length > 0) {
      *PropertyLength = pInfo->EventPropertyInfoArray[i].length;
    } else {
      // If the property is a binary blob and is defined in a MOF class, the
      // extension qualifier is used to determine the size of the blob.
      // However, if the extension is IPAddrV6, you must set the
      // PropertyLength variable yourself because the
      // EVENT_PROPERTY_INFO.length field will be zero.

      if (TDH_INTYPE_BINARY ==
              pInfo->EventPropertyInfoArray[i].nonStructType.InType &&
          TDH_OUTTYPE_IPV6 ==
              pInfo->EventPropertyInfoArray[i].nonStructType.OutType) {
        *PropertyLength = (USHORT)sizeof(IN6_ADDR);
      } else if (TDH_INTYPE_UNICODESTRING ==
                     pInfo->EventPropertyInfoArray[i].nonStructType.InType ||
                 TDH_INTYPE_ANSISTRING ==
                     pInfo->EventPropertyInfoArray[i].nonStructType.InType ||
                 (pInfo->EventPropertyInfoArray[i].Flags & PropertyStruct) ==
                     PropertyStruct) {
        *PropertyLength = pInfo->EventPropertyInfoArray[i].length;
      } else {
        wprintf(L"Unexpected length of 0 for intype %d and outtype %d\n",
                pInfo->EventPropertyInfoArray[i].nonStructType.InType,
                pInfo->EventPropertyInfoArray[i].nonStructType.OutType);

        status = ERROR_EVT_INVALID_EVENT_DATA;
        goto cleanup;
      }
    }
  }

cleanup:

  return status;
}

// Get the size of the array. For MOF-based events, the size is specified in
// the declaration or using the MAX qualifier. For manifest-based events, the
// property can specify the size of the array using the count attribute. The
// count attribue can specify the size directly or specify the name of another
// property in the event data that contains the size.

DWORD TDH::GetPropertyArraySize(PEVENT_RECORD pEvent, PTRACE_EVENT_INFO pInfo,
                                USHORT i, PUSHORT ArraySize) {
  DWORD status = ERROR_SUCCESS;
  PROPERTY_DATA_DESCRIPTOR DataDescriptor;
  DWORD PropertySize = 0;

  if ((pInfo->EventPropertyInfoArray[i].Flags & PropertyParamCount) ==
      PropertyParamCount) {
    DWORD Count = 0; // Expects the count to be defined by a UINT16 or UINT32
    DWORD j = pInfo->EventPropertyInfoArray[i].countPropertyIndex;
    ZeroMemory(&DataDescriptor, sizeof(PROPERTY_DATA_DESCRIPTOR));
    DataDescriptor.PropertyName =
        (ULONGLONG)((PBYTE)(pInfo) +
                    pInfo->EventPropertyInfoArray[j].NameOffset);
    DataDescriptor.ArrayIndex = ULONG_MAX;
    status =
        TdhGetPropertySize(pEvent, 0, NULL, 1, &DataDescriptor, &PropertySize);
    status = TdhGetProperty(pEvent, 0, NULL, 1, &DataDescriptor, PropertySize,
                            (PBYTE)&Count);
    *ArraySize = (USHORT)Count;
  } else {
    *ArraySize = pInfo->EventPropertyInfoArray[i].count;
  }

  return status;
}

// Both MOF-based events and manifest-based events can specify name/value
// maps. The map values can be integer values or bit values. If the property
// specifies a value map, get the map.

DWORD TDH::GetMapInfo(PEVENT_RECORD pEvent, LPWSTR pMapName,
                      DWORD DecodingSource, PEVENT_MAP_INFO &pMapInfo) {
  DWORD status = ERROR_SUCCESS;
  DWORD MapSize = 0;

  // Retrieve the required buffer size for the map info.

  status = TdhGetEventMapInformation(pEvent, pMapName, pMapInfo, &MapSize);

  if (ERROR_INSUFFICIENT_BUFFER == status) {
    pMapInfo = (PEVENT_MAP_INFO)malloc(MapSize);
    if (pMapInfo == NULL) {
      wprintf(L"Failed to allocate memory for map info (size=%lu).\n", MapSize);
      status = ERROR_OUTOFMEMORY;
      goto cleanup;
    }

    // Retrieve the map info.

    status = TdhGetEventMapInformation(pEvent, pMapName, pMapInfo, &MapSize);
  }

  if (ERROR_SUCCESS == status) {
    if (DecodingSourceXMLFile == DecodingSource) {
      RemoveTrailingSpace(pMapInfo);
    }
  } else {
    if (ERROR_NOT_FOUND == status) {
      status = ERROR_SUCCESS; // This case is okay.
    } else {
      wprintf(L"TdhGetEventMapInformation failed with 0x%x.\n", status);
    }
  }

cleanup:

  return status;
}

// The mapped string values defined in a manifest will contain a trailing
// space in the EVENT_MAP_ENTRY structure. Replace the trailing space with a
// null- terminating character, so that the bit mapped strings are correctly
// formatted.

void TDH::RemoveTrailingSpace(PEVENT_MAP_INFO pMapInfo) {
  DWORD ByteLength = 0;

  for (DWORD i = 0; i < pMapInfo->EntryCount; i++) {
    ByteLength = (wcslen((LPWSTR)((PBYTE)pMapInfo +
                                  pMapInfo->MapEntryArray[i].OutputOffset)) -
                  1) *
                 2;
    *((LPWSTR)((PBYTE)pMapInfo +
               (pMapInfo->MapEntryArray[i].OutputOffset + ByteLength))) = L'\0';
  }
}

// Get the metadata for the event.
DWORD TDH::GetEventInformation(PEVENT_RECORD pEvent, PTRACE_EVENT_INFO &pInfo) {
  DWORD status = ERROR_SUCCESS;
  DWORD BufferSize = 0;

  // Retrieve the required buffer size for the event metadata.

  status = TdhGetEventInformation(pEvent, 0, NULL, pInfo, &BufferSize);

  if (ERROR_INSUFFICIENT_BUFFER == status) {
    pInfo = (TRACE_EVENT_INFO *)malloc(BufferSize);
    if (pInfo == NULL) {
      wprintf(L"Failed to allocate memory for event info (size=%lu).\n",
              BufferSize);
      return ERROR_OUTOFMEMORY;
    }

    // Retrieve the event metadata.

    status = TdhGetEventInformation(pEvent, 0, NULL, pInfo, &BufferSize);
  }

  if (ERROR_SUCCESS != status) {
    wprintf(L"TdhGetEventInformation failed with 0x%x.\n", status);
  }

  return status;
}

// End copy/paste from MSDN.
